;   openorchestra.csd, a CSound unified format file for running scores
;   generated by scorealgorithm1.py
;   Copyright (C) 2011  Kevin James
;
;   This program is free software: you can redistribute it and/or modify
;   it under the terms of the GNU General Public License as published by
;   the Free Software Foundation, either version 3 of the License, or
;   (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License
;   along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
;   http://www.musicbykevinjames.com

<CsoundSynthesizer>

<CsOptions>
-o example.wav -W --format=short -Z -d
</CsOptions>

<CsInstruments>
sr = 44100
kr = 44100
ksmps = 1
nchnls = 2
0dbfs = 32767

;Global constants

;normalization factor
;ampdbfs(-4) == 20674.580
;ampdbfs(-3) == 23197.260
;ampdbfs(-2) == 26027.754
;ampdbfs(-1) == 29203.620
;ampdbfs(-.5) == 3093.043
;ampdbfs(0) == 32767.000
ginorm	=	1

;amplitude of amplitude jitter (added to amplitude)
giampjitamp	=	.008 * 0dbfs
;amplitude of timbre jitter (added to timbre)
gitimbjitamp	=	.009
;amplitude of frequency jitter (multiplied to frequency and added to frequency)
gifqcjitamp	=	.001
;factor to multiply minimum vibrato frequency to get maximum vibrato frequency
givibrfqcfact	=	1.6
;time to reach maximum vibrato frequency
givibrfqctim	=	.9

;global reverb signal
gareverbl	init	0
gareverbr	init	0






;a description of zak space:
;values are indexed according to their part index (the number after the decimal in p1)
;values stored in zak space are listed below with their index formula:
;attack:			part index + 0
;decay:				part index + 100
;sustain:			part index + 200
;release:			part index + 300
;pan:				part index + 400
;minimum vibrato amplitude:	part index + 500
;maximum vibrato amplitude:	part index + 600
;vibrato frequency:		part index + 700
;vibrato development time	part index + 800
;attack envelope curve:		part index + 900
;decay envelope curve:		part index + 1000
;sustain envelope curve:	part index + 1100
;release envelope curve:	part index + 1200
;portamento time:		part index + 1300
;output gain:			part index + 1400

;initialize zak space
	zakinit	1,1500
	




;Opcode definitions

;*******************************************
;*******************************************
;*******************************************
;Declaration of constants for each instrument

opcode	ConstantsDeclaration, iiiiiiiiiii, iiiiiii

;gather inputs with xin
ip1, ip2, ip3, ip4, ip5, ip6, ip7	xin

;the index associated with a certain part for zak space
ipartindex	=	round(frac(ip1) * 100)
;duration of note
idur		=	abs(ip3)
;fundamental frequency
ifqc		=	ip4
;intensity
iint		=	ip5
;maximum change in intensity
iintdiff	=	ip6 * .8
;maximum amplitude
iamp		=	(.2 + (.8 * iint)) * 0dbfs / (logbtwo(ifqc) / 4)
;timbre
itimb		=	ip7

;get adsr values from zak space and randomize them somewhat
iattval	zir	ipartindex + 0
iatt	=	iattval + rnd(0.1 * iattval)
idecval	zir	ipartindex + 100
isusval	zir	ipartindex + 200
isus	=	isusval + rnd(0.05 * isusval)
idec	=	idecval + rnd(0.1 * idecval)
irelval	zir	ipartindex + 300
irel	=	irelval + rnd(0.1 * irelval)

itie	tival

;this is a note that starts a phrase and ties with the note after
if (ip3 < 0 && itie == 0) then
	;make sure segments do not exceed note duration
	if (iatt + idec > idur) then
		;find the maximum duration for envelope segments
		iatt	=	idur / 3
		idec	=	idur / 3
	endif

;this is a note in the middle of a phrase that is tied to the note before and after
elseif (p3 < 0 && itie == 1) then
	;make sure segments do not exceed note duration
	if (iatt + idec > idur) then
		;find the maximum duration for envelope segments
		iatt	=	idur / 3
		idec	=	idur / 3
	endif

;this is a note at the end of a phrase that ties to the note before
elseif (p3 > 0 && itie == 1) then
	;make sure segments do not exceed note duration
	if (iatt + idec + irel > idur) then
		;find the maximum duration for envelope segments
		iatt	=	idur / 4
		idec	=	idur / 4
		irel	=	idur / 4
	endif

;this note is not tied to the note before or after
elseif (p3 > 0 && itie == 0) then
	;make sure segments do not exceed note duration
	if (iatt + idec + irel > idur) then
		;find the maximum duration for envelope segments
		iatt	=	idur / 4
		idec	=	idur / 4
		irel	=	idur / 4
	endif

endif

;output result with xout
	xout	ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel

endop

;*******************************************
;*******************************************
;*******************************************
;Envelope creator

opcode	EnvelopeMaker, aaa, iiiiiiiiii

;gather inputs with xin
ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb, xin

;convert intensity to amplitude value
iampdiff	=	iintdiff * 0dbfs

;find minimum of sustain and iintdiff
if ((isus * iamp) + iampdiff) < 0 then
	imin	=	0
elseif ((isus * iamp) + iampdiff) >= 0 then
	imin	=	(isus * iamp) + iampdiff
endif

;find curve and portamento time
iattcurve	zir	ipartindex + 900
ideccurve	zir	ipartindex + 1000
isuscurve	zir	ipartindex + 1100
irelcurve	zir	ipartindex + 1200
iport		zir	ipartindex + 1300

;process for finding amplitude and frequency envelopes according to tied status
;if note is not tied, the variable storing the old amplitude and frequency are set, otherwise it is carried over from last instance of instrument
	tigoto	skipreinit
ioldamp	init	iamp
ioldfqc	init	ifqc
ioldtimb	init	itimb

skipreinit:
;find envelopes based on whether note is tied to notes before and/or after
itie	tival

;this is a note that starts a phrase and ties with the note after
if (p3 < 0 && itie == 0) then
	;make adsr envelope
	aampenv	transeg	0, iatt, iattcurve, iamp, idec, ideccurve, isus * iamp, idur - (iatt + idec), isuscurve, imin, 1, 0, imin
	;draw a line between old and new frequency
	afqcenv	linseg	ifqc, idur, ifqc
	;draw a line between old and new timbre
	atimbenv	linseg	itimb, idur, itimb
	;set amplitude value for next note
	ioldamp	=	imin

;this is a note in the middle of a phrase that is tied to the note before and after
elseif (p3 < 0 && itie == 1) then
	;make adsr envelope
	aampenv	transeg	ioldamp, iatt, iattcurve, iamp, idec, ideccurve, isus * iamp, idur - (iatt + idec), isuscurve, imin, 1, 0, imin
	;draw a line between old and new frequency
	afqcenv	linseg	ioldfqc, iport, ifqc, idur - iport, ifqc
	;draw a line between old and new timbre
	atimbenv	linseg	ioldtimb, iport, itimb, idur - iport, itimb
	;set amplitude value for next note
	ioldamp	=	imin

;this is a note at the end of a phrase that ties to the note before
elseif (p3 > 0 && itie == 1) then
	;make adsr envelope
	aampenv	transeg	ioldamp, iatt, iattcurve, iamp, idec, ideccurve, isus * iamp, idur - (iatt + idec + irel), isuscurve, imin, irel, irelcurve, 0, 1, 0, 0
	;draw a line between old and new frequency
	afqcenv	linseg	ioldfqc, iport, ifqc, idur - iport, ifqc
	;draw a line between old and new timbre
	atimbenv	linseg	ioldtimb, iport, itimb, idur - iport, itimb
	;set amplitude value for next note
	ioldamp	=	0

;this note is not tied to the note before or after
elseif (p3 > 0 && itie == 0) then
	;make adsr envelope
	aampenv	transeg	0, iatt, iattcurve, iamp, idec, ideccurve, isus * iamp, idur - (iatt + idec + irel), isuscurve, imin, irel, irelcurve, 0, 1, 0, 0
	;draw a line between old and new frequency
	afqcenv	linseg	ifqc, idur, ifqc
	;draw a line between old and new timbre
	atimbenv	linseg	itimb, idur, itimb
	;set amplitude value for next note
	ioldamp	=	0

endif

;set frequency and timbre values for next note
ioldfqc	=	ifqc
ioldtimb	=	itimb

;add jitter to amplitude and timbre enveloeps
;create an envelope for the jitter to prevent discontinuities
ajitenv	linseg	0, .01, 1, idur - .02, 1, .01, 0
;create an amplitude jitter
ajit1	jspline	giampjitamp * isus, 4, 6
;add result to amplitude envelope
aampout	=	aampenv + (ajit1 * ajitenv)
;create a timbre jitter
ajit2	jspline	gitimbjitamp, 4, 6
;add result to timbre envelope
atimbout	=	atimbenv + (ajit2 * ajitenv)
;limit timbre envelope to values between 0 and 1
atimblim	limit	atimbout, 0, 1
;create a frequency jitter
ajit3	jspline	gifqcjitamp, 4, 6
;add multiplied result to frequency envelope
afqcout	=	afqcenv + (ajit3 * ajitenv * afqcenv)

;output result with xout
	xout	aampout, afqcout, atimblim

endop

;*******************************************
;*******************************************
;*******************************************
;Vibrato function

opcode	Vibrato, a, iiiiia

;get inputs with xin
ipartindex, idur, ifqc, iint, iintdiff, afqcenv	xin

;get maximum vibrato amplitude from zak space and add in intensity and a random factor
iminvibrampval	zir	ipartindex + 500
iminvibramp	=	(iminvibrampval + (.5 * iint) + rnd(.1 * iint)) * (ifqc / 100)
imaxvibrampval	zir	ipartindex + 600
imaxvibramp	=	(imaxvibrampval + (.5 * iint) + rnd(.1 * iint)) * (ifqc / 100)
;get minimum vibrato frequency from zak space and add in intensity and a random factor
iminvfqcval	zir	ipartindex + 700
iminvfqc	=	iminvfqcval + (iint * .6) + rnd(.1)
;also find maximum vibrato frequency from minimum value
imaxvfqc	=	(iminvfqcval * givibrfqcfact) + (iint * .6) + rnd(.1)
;get vibrato development time from zak space
ivibrtime	zir	ipartindex + 800

;make envelope for vibrato amplitude
iseglen1a	=	ivibrtime + rnd(.1 * ivibrtime)
kvamplin	linseg	iminvibramp * .1, iseglen1a, imaxvibramp, idur - iseglen1a, (imaxvibramp + (iintdiff * imaxvibramp * .3)) * .7
;make smooth transition in vibrato between notes
kvamp	port	kvamplin, .01, -1

;make envelope for vibrato frequency
iseglen1b	=	ivibrtime + rnd(.1)
kvfqclin	linseg	iminvfqc, iseglen1b, imaxvfqc, idur - iseglen1b, imaxvfqc
;make smooth transition in vibrato between notes
kvfqc	port	kvfqclin, .01, -1

;create vibrato
;expects table 1 to be a waveform
kvibr	vibrato	kvamp, kvfqc, .01, .01, 3, 4, 3, 4, 1, -1
;upsample output of vibrato
avibr	upsamp	kvibr
;apply vibrato to fundamental frequency
afqc	=	afqcenv + avibr

;output result with xout
	xout	afqc

endop

;*******************************************
;*******************************************
;*******************************************
;Sinc-interpolating oscillator

opcode	SincOscil, a, aaii

;gather inputs with xin
aamp, afqc, itab, iphs	xin

;set the value of pi
ipi	=	3.14159265
;set the number of levels
ilevel	=	48

;downsample frequency value
kfqc	downsamp	afqc
;create a moving phase value
kphas	phasor	kfqc, iphs
;get the table index from phase value
kndxp	=	int(kphas * 65536)
;use another table index for checking previous values
kndxn	=	kndxp
;get the fraction of table index value
kfrac	=	(kphas * 65536) - kndxp
;initialize the function
kval	table	kndxp, itab
aval	upsamp	kval
;compute sinc function for first value
asig	=	(kfrac == 0) ? aval : aval * sin(kfrac*ipi) / kfrac / ipi

;initialize a loop
kcount	=	0
;iterate through adjacent values
loop:
if (kcount >= ilevel) goto cont
;increment value and check for wraparound
kndx	=	(kndxp == 65536-1) ? 0 : kndxp + 1
;get the next table value
kval	table	kndx, itab
aval	upsamp	kval
;calculate window
kfraccount	=	kfrac - (kcount + 1)
kwin	=	.5 + .5 * cos(kfraccount * ipi / ilevel)
;calculate the sinc function
asinc	=	(kfraccount == 0) ? aval : kwin * aval * sin(kfraccount * ipi) / kfraccount / ipi
;add the sinc value to the signal
asig	=	asig + asinc
;keep track of the current table index going forwards
kndxp	=	kndx

;decrement value and check for wraparound
kndx	=	(kndxn == 0) ? itab - 1 : kndx - 1
;get the previous table value
kval	table	kndx, itab
aval	upsamp	kval
;calculate the window
kfraccount	=	kfrac + (kcount + 1)
kwin	=	.5 + .5 * cos(kfraccount * ipi / ilevel)
;calculate the sinc function
asinc	=	(kfraccount == 0) ? aval : kwin * aval * sin(kfraccount * ipi) / kfraccount / ipi
;add the sinc value to the sisgnal
asig	=	asig + asinc
;keep track of the current table index going backwards
kndxn	=	kndx

;increment the loop count
kcount	=	kcount + 1
	goto	loop

cont:
;output result
	xout	asig * aamp

endop

;*******************************************
;*******************************************
;*******************************************
;Subtractive synthesis sound

opcode	SubtractiveSound, a, iai

;get inputs with xin
imode, afqc, idur	xin

;downsample frequency signal
kfqc	downsamp	afqc

;get tied status of note
itie	tival

;get a randomized pulsewidth value
kspline	jspline	.2, 3, 4
;portamento between pulsewidth values
kport	port	kspline, .1, -1
;apply an envelope
kpwenv	linseg	0, .01, 1, idur - .02, 1, .01, 0
;scale value and apply envelope
kpw	=	(kport * kpwenv) + .4

;subtractive synthesis
asig	vco2	1, kfqc, imode + itie, kpw, 0, .5

;output result
	xout	asig

endop

;*******************************************
;*******************************************
;*******************************************
;Scanned synthesis opcode

opcode Scanned, a, aaiiiii

;get inputs with xin
aampenv, afqc, itab1, itab2, itab3, itab4, itab5	xin

;downsample aampenv and afqc so that they can be used with scantable
kampenv	downsamp	aampenv
kfqc	downsamp	afqc

;scanned synthesis
;expects itab1-5 to be scanned synthesis parameters
ascan	scantable	kampenv, kfqc, itab1, itab2, itab3, itab4, itab5

;output result with xout
	xout	ascan

endop

;*******************************************
;*******************************************
;*******************************************
;Modal filter opcode

opcode ModalFilter, a, aaa

;get inputs with xin
afqc, atimbenv, aimpls	xin

;downsample envelopes
kfqc	downsamp	afqc
ktimbenv	downsamp	atimbenv

;filter input
;glass sound
amode1	mode	aimpls, kfqc * 1, ((1 - ktimbenv) * 1000) + 500, -1
amode2	mode	aimpls, kfqc * 2.32, ((1 - ktimbenv) * 1000) + 500, -1
amode3	mode	aimpls, kfqc * 4.25, ((1 - ktimbenv) * 1000) + 500, -1
amode4	mode	aimpls, kfqc * 6.63, ((1 - ktimbenv) * 1000) + 500, -1
amode5	mode	aimpls, kfqc * 9.38, ((1 - ktimbenv) * 1000) + 500, -1
;mix result
amix	=	(amode1 + amode2 + amode3 + amode4 + amode5) * .2

;output result with xout
	xout	amix

endop

;*******************************************
;*******************************************
;*******************************************
;Output function

opcode	Output, 0, ia

;gather inputs with xin
ipartindex, aout	xin

;panning
;get pan value from zak space
kpan	zkr	ipartindex + 400
apanl, apanr	pan2	aout, kpan

;get gain value from zak space
kgain		zkr	ipartindex + 1400

;apply gain value and normalization to the signal
aoutl	=	apanl * kgain
aoutr	=	apanr * kgain

;output
	outs	aoutl * ginorm, aoutr * ginorm

;send signal to reverb instrument
gareverbl	=	gareverbl + aoutl
gareverbr	=	gareverbr + aoutr

endop







;Instrument definitions

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Series 100: Global parameters

;*******************************************
;*******************************************
;*******************************************
instr 101
;Output gain control

;declaration of constants
;duration of note
idur		=	abs(p3)
;the index associated with a certain part for zak space
ipartindex	=	round(frac(p1) * 100)
;starting and ending gain values for this part number
istartval	=	p4
iendval		=	p5

;make a line between starting and ending values
kline	line	istartval, idur, iendval
kport	port	kline, .01, -1
;limit value to above 0
klim	limit	kport, 0, 10000

;write gain value to zak space
	zkw	klim, ipartindex + 1400

endin

;*******************************************
;*******************************************
;*******************************************
instr 102
;Global adsr instrument

;declaration of constants
;the index associated with a certain part for zak space
ipartindex	=	round(frac(p1) * 100)
;Read parameter values from p-fields
iatt	=	p4
idec	=	p5
isus	=	p6
irel	=	p7

;write adsr values to zak space
	ziw	iatt, ipartindex + 0
	ziw	idec, ipartindex + 100
	ziw	isus, ipartindex + 200
	ziw	irel, ipartindex + 300

endin

;*******************************************
;*******************************************
;*******************************************
instr 103
;Global panning instrument

;declaration of constants
;duration of note
idur		=	abs(p3)
;the index associated with a certain part for zak space
ipartindex	=	round(frac(p1) * 100)
;starting and ending pan values for this part number
istartval	=	p4
iendval		=	p5

;make a line between starting and ending values
kline	line	istartval, idur, iendval
;portamento between pan values
kport	port	kline, .02, -1

;write pan value to zak space
	zkw	kport, ipartindex + 400

endin

;*******************************************
;*******************************************
;*******************************************
instr 104
;Global vibrato amplitude instrument

;declaration of constants
;the index associated with a certain part for zak space
ipartindex	=	round(frac(p1) * 100)
;vibrato amplitude values for this part number
iminvibramp	=	p4
imaxvibramp	=	p5
;vibrato frequency value for this part number
ivibrfqc	=	p6
;vibrato development time for this part number
ivibrtime	=	p7

;write minimum vibrato amplitude value to zak space
	ziw	iminvibramp, ipartindex + 500
;write maximum vibrato amplitude value to zak space
	ziw	imaxvibramp, ipartindex + 600
;write vibrato frequency value to zak space
	ziw	ivibrfqc, ipartindex + 700
;write vibrato development time to zak space
	ziw	ivibrtime, ipartindex + 800

endin

;*******************************************
;*******************************************
;*******************************************
instr 105
;Global envelope parameter instrument

;declaration of constants
;the index associated with a certain part for zak space
ipartindex	=	round(frac(p1) * 100)
;envelope curve values for this part number
iattcurve	=	p4
ideccurve	=	p5
isuscurve	=	p6
irelcurve	=	p7
;portamento time for this part number
iport		=	p8

;write envelope values to zak space
	ziw	iattcurve, ipartindex + 900
	ziw	ideccurve, ipartindex + 1000
	ziw	isuscurve, ipartindex + 1100
	ziw	irelcurve, ipartindex + 1200
;write portamento time to zak space
	ziw	iport, ipartindex + 1300

endin

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Series 200: Additive physical models

;*******************************************
;*******************************************
;*******************************************
instr 207
;Bassoon

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;additive synthesis
;amplitude envelope for attack phase
aenv1	linseg	0, iatt, 1, idec, 0, 1, 0
;expects tables 20701 and 20702 to be waveforms
asnd1	oscil3	aenv1, afqc, 20701, -1
asnd2	oscil3	1 - aenv1, afqc, 20702, -1
;apply envelope
aout	=	(asnd1 + asnd2) * aampenv

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 208
;Chorus organ sound

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv1, afqcenv1, atimbenv1	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb
aampenv2, afqcenv2, atimbenv2	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb
aampenv3, afqcenv3, atimbenv3	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv1

;additive synthesis
;expects tables 3 and 8 to be waveforms
asnda1	oscil3	aampenv1, afqc, 3, -1
asnda2	oscil3	aampenv2, afqc, 3, -1
asnda3	oscil3	aampenv3, afqc, 3, -1
asndb1	oscil3	aampenv1, afqc, 8, -1
asndb2	oscil3	aampenv2, afqc, 8, -1
asndb3	oscil3	aampenv3, afqc, 8, -1

;chiff
;make chiff envelope
achiffenv	linseg	0, iatt, 1, idec, .4, idur - (iatt + idec + irel), .4, irel, 0
;band-pass filter noise
anoise	rand	1
achiff1	butbp	anoise, ifqc, 45, -1
achiff2	butbp	anoise, ifqc * .5, 45, -1
achiff3	balance	achiff1 + achiff2, anoise, 10, -1
achiff	=	achiff3 * achiffenv

;Sum output and add global amplitude scale
aout	=	((asnda1 + asnda2 + asnda3) * ((1/3) * .998) * (1 - atimbenv1)) + ((asndb1 + asndb2 + asndb3) * ((1/3 * .998) * atimbenv1)) + (achiff * .002)

;output result
	Output	ipartindex, aout

endin

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Series 500: Digital synthesis instruments

;*******************************************
;*******************************************
;*******************************************
instr 501
;Sawtooth

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;subtractive synthesis
imode	=	0
asnd	SubtractiveSound	imode, afqc, idur

;get tied value of note
itie	tival
;downsample amplitude, frequency, and timbre envelopes
kampenv		downsamp	aampenv
kfqcenv		downsamp	afqcenv
ktimbenv	downsamp	atimbenv
;filter signal
afilt	tonex	asnd, kfqcenv * (1 + ktimbenv) * (1 + (kampenv / 0dbfs)), 4, -itie
;balance result
abal	balance	afilt, asnd, 10, -1
;add in amplitude envelope
aout	=	abal * aampenv

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 502
;Sine wave

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;Additive synthesis
;expects table 1 to be a waveform
asnd1	oscil3	aampenv, afqc, 1, -1
asnd2	oscil3	aampenv, afqc * 2, 1, -1

;sum outputs
aout	=	(asnd1 * (1 - atimbenv) * .5) + (asnd1 * .5) + (asnd2 * atimbenv * .5)

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 503
;Waveterrain

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;evolving index amplitude
ilintim	=	.1 + rnd(.05)
kndx	linseg	0, ilintim, 0, ilintim * 10, .99, idur - ilintim * 11, .99
kport	port	kndx, .01, -1
;index a table to get change in timbre
;expects table 203 to be a transfer function
andx	table3	atimbenv * kport, 203, 1
;add a random factor
arndx	randi	.05, 5, -1
arndy	randi	.01, 5, -1
;find initialization values of phases by seeing if note is tied
itie	tival

;index set 1
if (itie == 1) then
	;note is tied to the previous note, oscillators skip reinitialization phase
	iphs1	=	-1
	iphs2	=	-1
elseif (itie == 0) then
	;note is not tied to the previous note, oscillators are 90 degrees out of phase to form a circle
	iphs1	=	0
	iphs2	=	.25
endif
;x and y values are 90 degrees out of phase to form a circle
;expects table 1 to be a waveform
ax1	oscil3	(andx * 1) + arndx, afqc, 1, iphs1
ax2	oscil3	(andx * .25) + .25 + arndy, afqc * 2, 1, iphs2
ax	=	ax1 + ax2
ay	oscil3	(andx * .375) + .25 + arndy, afqc, 1, iphs2

;waveterrain synthesis
;generates a z value according to a formula using hyperbolic tangent, natural logarithm, and sine wave
asnd	=	(tanh(exp(ax) - 1) + sin(8 * cos(2 * ay) * tan(ay)))
;downsample amplitude, frequency, and timbre envelopes
kampenv		downsamp	aampenv
kfqcenv		downsamp	afqcenv
ktimbenv	downsamp	atimbenv
;filter signal
afilt	tonex	asnd, kfqcenv * 2 * (1 + ktimbenv) * (1 + (kampenv / 0dbfs)), 4, -itie
ahpfilt	buthp	afilt, 10, -1
;make a comparison signal to balance amplitude
;expects table 1 to be a waveform
acomp	oscil3	1, afqc, 1, -1
;balance signal against comparison
aout	balance	ahpfilt * aampenv, acomp * aampenv, 10, -1

;output result
	Output	ipartindex, aout
	
endin

;*******************************************
;*******************************************
;*******************************************
instr 504
;Fractal-modulated granular

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;get tied status of note
itie	tival
;see if note is tied
if (itie == 0) then
	;note is not tied, initialize oscillators at 90 degrees
	iphs1	=	0
	iphs2	=	.25
elseif (itie == 1) then
	;note is tied, do not initialize oscillators
	iphs1	=	-1
	iphs2	=	-1
endif
;downsample amplitude, frequency, and timbre envelopes for cutoff frequency
kampenv		downsamp	aampenv
kfqcenv		downsamp	afqcenv
kfqc		downsamp	afqc
ktimbenv	downsamp	atimbenv
;create an moving index value
;expects table 1 to be a waveform
kline	oscil3	.195, kfqc, 1, -1
kx1	oscil3	.1 + kline, kfqc, 1, iphs1
kx	=	kx1 - 1
;x and y values are 90 degrees out of phase to form a circle
ky1	oscil3	.1 + kline, kfqc + (kfqc * .01), 1, iphs2
ky	=	ky1 - 1
;input trigger for mandel opcode
kintrig	init	1
;Finding the number of iterations required to prove point is outside Mandelbrot set
kiter, kouttrig	mandel	kintrig, kx, ky, 10
;interpolate between new values of kiter
kport	port	kiter, .01, -1
;reset trigger
if kouttrig == 1 then
	kintrig	=	1
endif

;create a clock to keep track of duration
iclock	=	0
;grain generator
grain_function:
	;find duration of time until next grain
	igrdur	=	1 / ifqc
	;see if end of grain would exceed note duration
	if (iclock + igrdur > idur) then
		;do not generate sound for this grain
		igramp	=	0
		;initialize oscillators
		iphs	=	0
	elseif (iclock == 0) then
		;generate sound for this grain
		igramp	=	1
		;but do not initialize oscillators
		iphs	=	-1
	elseif (iclock + igrdur <= idur) then
		;generate sound for this grain
		igramp	=	1
		;initialize oscillators
		iphs	=	0
	endif
	;add grain duration to clock
	iclock	=	iclock + igrdur
	;indexing function for grain window
	;expects table 201 to be a transfer function
	kndx	oscil3	2, 2 / igrdur, 201, iphs
	andx	upsamp	kndx
	;look up window from a table using aindex
	;expects table 102 to be a window function
	awindowenv	table3	andx, 102, 1, 0, 1
	;expects table 1 to be a waveform
	asnd	oscil3	(kport * itimb) + (1 - itimb), kfqc, 3, iphs
	;apply window to sound
	agrain = asnd * awindowenv
	;continue generating grain until iduration is complete
	timout 0, igrdur, continue
	;make sure grain is completed
	if kndx == 1 then
		;and reinitialize if true
		reinit grain_function
	endif								
	;if iduration is not complete, continue with sound generation
	continue:
rireturn

;filter signal
afilt1	tonex	agrain, kfqcenv * (1 + ktimbenv) * (1 + (4 * (kampenv / 0dbfs))), 4, -itie
afilt2	buthp	afilt1, 10, -1
;create a comparison signal
;expects table 1 to be a waveform
acomp	oscil3	1, kfqc, 1, -1
;balance result
abal	balance	afilt2, acomp, 10, -1
;add in amplitude envelope
aout	=	abal * aampenv
;aout	=	agrain * aampenv

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 505
;Feedback phase modulation

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;downsample amplitude, frequency, and timbre envelopes
kampenv		downsamp	aampenv
kfqcenv		downsamp	afqcenv
ktimbenv	downsamp	atimbenv

;feedback phase modulation
;initialize feedback signal
afdbk1	init	0
afdbk2	init	0
;create signals for modifying index
;expects table 1 to be a waveform
andxphas	oscil3	1, 1.8, 1, -1
;create index envelope based on moving phase, amplitude, and timbre envelopes
andx1	=	((andxphas * .3) + (aampenv * .8 / 0dbfs) + (atimbenv * 1.9) + .9) / ((afqcenv / 10)^4)
;get deviation by dividing index by 2pi
adev1	=	andx1 / 6.2831
;multiply first envelope to get second
adev2	=	(adev1 * 120) + (.4 * itimb)
;get a moving phase value for modulator
amodphas1	phasor	afqc, -1
amodphas2	phasor	afqc * 2, -1
amodphas3	phasor	afqc * 3, -1
;create a modulator signal
;expects table 1 to be a waveform
amod1	table3	amodphas1 + (afdbk1 * adev1), 1, 1, 0, 1
amod2	table3	amodphas2 + (afdbk1 * adev1), 1, 1, 0, 1
amod3	table3	amodphas3 + (afdbk1 * adev1), 1, 1, 0, 1
;get a moving phase value for carrier
acarrphas	phasor	afqc, -1
;create modulated carrier signal
;expects table 1 to be a waveform
acarr	table3	acarrphas + (amod1 * adev2) + (amod2 * adev2 * .1) + (amod3 * adev2 * .01) + (afdbk2 * adev1), 1, 1, 0, 1

;create an attack phase of the sound
;make an envelope controlling timbre
aiintenv	linseg	0, iatt, iint / ((logbtwo(ifqc) / 4)), idec, 0, idur - (iatt + idec), 0
;create a noise signal
arand	randi	aiintenv, afqcenv * .2, -1
;create attack portion of sound
;expects table 1 to be a waveform
aatk	oscil3	arand, 2000, 1, -1
;filter attack portion of sound
aatkfilt	reson	aatk, kfqcenv, 1, 1, -1

;filter signal
;get tied status of note
itie	tival
;filter signal
kcolin	linseg	0, 1.2, itimb, 1, itimb
kcoport	port	kcolin, .1, -1
afilt1	tonex	acarr + aatkfilt, kfqcenv + (kfqcenv * kcoport * 2), 4, -itie
afilt2	buthp	afilt1, 10, -1
;limit range
aclip	=	tanh(afilt2)
;feedback element using delay
afdbk1	vdelay3	aclip, .03 * (1.1 - aampenv), 1, -itie
afdbk2	delay1	afdbk1, -1

;balance signal
abal	balance	aclip, acarr, 10, -1
;limit range
aclip	=	tanh(abal)
;apply amplitude envelope
aout	=	aclip * aampenv

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 506
;Vectorial analysis

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;get tied status of note
itie	tival
;downsample amplitude, frequency, and timbre envelopes
kampenv		downsamp	aampenv
kfqc		downsamp	afqc
kfqcenv		downsamp	afqcenv
ktimbenv	downsamp	atimbenv

;define vectors in terms of intensity and timbre envelopes
ax	=	aampenv / 0dbfs * .5

;increase timbre over time
ilintim	=	.5 + rnd(.2)
kline1	linseg	0, ilintim, 0, ilintim * 2, .12, 1, .12
klineport	port	kline1, .01, -1
;make a second scaling value
ascal	=	(atimbenv * .5) + klineport
;limit the second value to .5
alim	init	.5
ay	min	ascal, alim

;additive synthesis
;expects table 1 to be a waveform
asnd1	oscil3	1, afqc, 1, -1

;phase modulation
;get an index using fractal data
andx	=	(aampenv / 0dbfs * .5) + (atimbenv * 2.5)
;get deviation by dividing index by 2pi
adev	=	andx / 6.2831
;get a moving phase value for modulator
amodphas1	phasor	afqc, -1
amodphas2	phasor	afqc * 2, -1
amodphas3	phasor	afqc * 3, -1
;create a modulator signal
;expects table 1 to be a waveform
amod1	table3	amodphas1, 1, 1, 0, 1
amod2	table3	amodphas2, 1, 1, 0, 1
amod3	table3	amodphas3, 1, 1, 0, 1
;create a moving phase value for carrier
acarrphas	phasor	afqc, -1
;create modulated carrier signal
;expects table 1 to be a waveform
acarr	table3	acarrphas + (amod1 * adev) + (amod2 * adev * .1) + (amod3 * adev * .01), 1, 1, 0, 1
;high-pass filter result
afilt1	buthp	acarr, 10, -1
;balance result
asnd2	balance	afilt1, asnd1, 10, -1

;subtractive synthesis
;find number of octaves below four fifths of nyquist frequency
asub	SubtractiveSound	4, afqc, idur
;create a cut-off frequency envelope
kco	port	ifqc, .1, -1
;filter signal
afilt2	tonex	asub, kfqcenv * (1 + ktimbenv) * (1 + (kampenv / 0dbfs)), 4, -itie
;balance result
asnd3	balance	afilt2, asnd1, 10, -1

;waveterrain synthesis
;evolving index amplitude
ilintim	=	.1 + rnd(.05)
kndx	linseg	0, ilintim, 0, ilintim * 10, .99, idur - ilintim * 11, .99
kport	port	kndx, .01, -1
;index a table to get change in timbre
;expects table 203 to be a transfer function
andx	table3	atimbenv * kport, 203, 1
;add a random factor
arndx	randi	.05, 5, -1
arndy	randi	.01, 5, -1
;find initialization values of phases by seeing if note is tied
itie	tival
;index set 1
if (itie == 1) then
	;note is tied to the previous note, oscillators skip reinitialization phase
	iphs1	=	-1
	iphs2	=	-1
elseif (itie == 0) then
	;note is not tied to the previous note, oscillators are 90 degrees out of phase to form a circle
	iphs1	=	0
	iphs2	=	.25
endif
;x and y values are 90 degrees out of phase to form a circle
;expects table 1 to be a waveform
ax1	oscil3	(andx * .1) + arndx, afqc, 1, iphs1
ax2	oscil3	(andx * .025) + .25 + arndy, afqc * 2, 1, iphs2
ax	=	ax1 + ax2
ay	oscil3	(andx * .0375) + .25 + arndy, afqc, 1, iphs2
;sound generation
;generates a z value according to a formula using hyperbolic tangent, natural logarithm, and sine wave
awave	=	(tanh(exp(ax) - 1) + sin(8 * cos(2 * ay) * tan(ay)))
;high-pass filter result
afilt3	buthp	awave, 10, -1
;balance result
asnd4	balance	afilt3, asnd1, 10, -1

;mix sounds according to vectors
asum	=	(asnd1 * (.5 - ax)) + (asnd2 * ax) + (asnd3 * (.5 - ay)) + (asnd4 * ay)
;balance signal against another sound
abal	balance	asum, asnd1, 10, -1
;apply envelope
aout	=	abal * aampenv

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 507
;Waveshaping

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;create a sound source
;expects table 1 to be a waveform
asnd1	oscil3	aampenv / 0dbfs, afqc, 1, -1
;expects table 3 to be a waveform
asnd2	oscil3	aampenv / 0dbfs, afqc, 3, -1
;mix two sounds together according to timbre
asnd	=	(asnd1 * (1 - atimbenv)) + (asnd2 * atimbenv)

;waveshaping with hyperbolic tangent
awave	=	tanh(asnd*6)
aout	balance	awave * 0dbfs, asnd * 0dbfs, 10, -1

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 510
;Pulse width modulation

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;envelope
aampenv, afqcenv, atimbenv	EnvelopeMaker	ipartindex, idur, ifqc, iintdiff, iamp, iatt, idec, isus, irel, itimb

;vibrato
afqc	Vibrato	ipartindex, idur, ifqc, iint, iintdiff, afqcenv

;generate an index modifier
;expects table 1 to be a waveform
andxmod	oscil3	.05 + (iint * .02), 2.2 + (iint * .1), 1, -1
;create an index
;expects table 3 to be a waveform
andx	oscil3	1, afqc, 3, -1
;pulse-width modulation
;expects table 10 to be a waveform
asnd	table3	(andx * .2) + (andxmod + .1), 10, 1, .5
;downsample amplitude, frequency, and timbre envelopes
ktimbenv	downsamp	atimbenv
kfqcenv		downsamp	afqcenv
kampenv		downsamp	aampenv
;get tied status of note
itie	tival
;filter result
afilt1	tonex	(asnd + andx) * .5, kfqcenv * (1 + ktimbenv) * (1 + (kampenv / 0dbfs)), 4, -itie
afilt2	buthp	afilt1, 10, -1
;balance signal
aout	balance	afilt2 * aampenv, andx * aampenv, 10, -1

;output result
	Output	ipartindex, aout

endin

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Series 700: Percussion instruments

;*******************************************
;*******************************************
;*******************************************
instr 706
;Sleighbells

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;sound synthesis
asnd	sleighbells	((iint * .9) + .1) * 0dbfs, .01
afilt	butlp	asnd, 1000 + (7000 * itimb), -1
aout	balance	afilt, asnd, 10, -1

;output result
	Output	ipartindex, aout

endin

;*******************************************
;*******************************************
;*******************************************
instr 707
;Tambourine

;declaration of constants
ipartindex, idur, ifqc, iint, iintdiff, iamp, itimb, iatt, idec, isus, irel	ConstantsDeclaration	p1, p2, p3, p4, p5, p6, p7

;sound synthesis
asnd	tambourine	((iint * .9) + .1) * 0dbfs, .01
afilt	butlp	asnd, 3000 + (7000 * itimb), -1
aout	balance	afilt, asnd, 10, -1

;output result
	Output	ipartindex, aout

endin

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Series 900: Effects processing

;*******************************************
;*******************************************
;*******************************************
instr 901
;Reverb instrument

;declaration of constants
;feedback
ifdbk	=	p4
;cutoff
ico	=	p5
;gain
igain	=	p6

;denorm signal
	denorm	gareverbl, gareverbr
;reverberate signal
aoutl, aoutr	reverbsc	gareverbl, gareverbr, ifdbk, ico

;create a declick envelope
aclick	linseg	1, abs(p3) - .01, 1, .01, 0

;output
	outs	aoutl * igain * aclick * ginorm, aoutr * igain * aclick * ginorm

;clear reverb signal
gareverbl	=	0
gareverbr	=	0

endin

</CsInstruments>

<CsScore>


;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;All-purpose waveforms

;sine wave
f1 0 65537 10 1
;square wave
f2 0 65537 7 1 16385 1 1 -1 32769 -1
;harmonic waveform
f3 0 65537 10 1 .1 .05
;triangle wave
f4 0 65537 7 0 16384 1 32768 -1 16385 0
;sawtooth
f5 0 65537 7 0 100 -1 65237 1 100 0
;double triangle
f6 0 65537 7 0 16384 1 16384 0 16384 -1 16385 0
;irregular sawtooth
f7 0 65537 7 0 18384 1 14384 0 14384 -1 18385 0
;another harmonic waveform
f8 0 65537 10 1 .4 .3
;triangle wave using additive synthesis
f9 0 65537 10 1 0 -.5 0 .33
;square wave using additive synthesis
f10 0 65537 10 1 0 .33 0 .2 0 .142857 0 .111111
;cosine wave
f11 0 65537 9 1 1 .25
;pulse wave
f12 0 65537 10 1 1 1 1 .7 .5 .3 .1

;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;Windows
;gaussian window
f101 0 65537 20 6
;hamming window
f102 0 65536 20 1 1

;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;Curves
;linear rise
f201 0 65536 7 0 65536 1
;segmented rise
f202 0 65536 7 0 32768 .9 32768 1
;spline-shaped rise
f203 0 65536 8 0 65536 1
;spline-shaped fall
f204 0 65536 8 1 65536 0
;linear sharp triangle
f205 0 65536 7 0 320 1 22400 0 42816 0
;exponential sharp triangle
f206 0 65536 5 .0001 96 1 14240 .0001 51200 .0001

;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;Noise
;triangular distribution
f301 0 512 21 3 1
;exponential distribution
f302 0 512 21 4 1
;biexponential distrubtion
f303 0 512 21 5 1
;gaussian distribution
f304 0 512 21 6 1
;beta distribution
f305 0 512 21 9 1 2 5
;weibull distribution
f306 0 512 21 4 1 2.5

;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;Scanned synthesis parameters

;initial position
f2001 0 128 7 0 64 1 64 0
;masses
f2002 0 128 -7 1 128 1
;stiffness
f2003 0 128 -7 0 64 100 64 0
;damping
f2004 0 128 -7 1 128 1
;initial velocity
f2005 0 128 -7 0 128 0

;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;+++++++++++++++++++++++++++++++++++++++++++
;Instrument 200 series parameters

;cut-off frequencies
f20001 0 16 -2 40 40 80 160 320 640 1280 2560 5120 10240 10240

;Instrument 207 parameters
;bassoon attack timbre
f20701 0 65537 10 1 .12 .425 .0625 .02 .01
;bassoon sustain timbre
f20702 0 65537 10 1 .06 .425 .0625 .002 .001

;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;|||||||||||||||||||||||||||||||||||||||||||
;Begin i-statement section









;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;
;PASTE Scorealgorithm1.py RESULTS BELOW
;
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%











</CsScore>

</CsoundSynthesizer>
